/*
 * The compare function should be a binary predicate (i.e. f(a,b)) that behaves in the
 * following way:
 * compare function should behave as less_than operator (i.e. a<b) in order to get a min-heap.
 * If it behaves as greater_than (i.e. a>b) the resulting structure is a max-heap.
 * 
 */



function Heap(compare){
	this.heap=new Array();	
	this.compare=compare;
}

MinHeap.prototype={		
	insert:function(element){
		this.heap[this.length]=element;		
		curr=this.heap.length-1;
		while(curr>0){
			var parent=(curr+1)/2-1;
			if(compare(this.heap[curr],this.heap[parent])){
				var tmp=this.heap[curr];
				this.heap[curr]=this.heap[parent];
				this.heap[parrent]=tmp;
				curr=parent;				
			}
			else{
				break;
			}
		}		
	}
	
	top:function(){
		return this.heap[0];
	}
	
	pop:function(){
		var ret=this.heap[0];
		var last=this.heap.pop();
		if(this.heap.length>0){
			this.heap[0]=last;
			var curr=0;
			while(true){
				var ind=(curr+1)*2-1;
				if(ind>=this.heap.length){
					//curr is a leaf node
					break;
				}					
				var next=-1;
				if(compare(this.heap[ind],this.heap[curr])){
					//left child is less than curr
					next=ind;
				}				
				ind+=1;
				if(ind<this.heap.length && compare(this.heap[ind],this.heap[curr])){
					//right child is less than curr
					if(next==-1){
						//left child isn't less than curr
						next=ind;
					}
					else{
						//left child is also less than curr
						if(compare(this.heap[ind],this.heap[next])){
							//right child is less than left child
							next=ind;
						}					
					}					
				}
				if(next==-1){
					//curr is less than both children
					break;
				}
				else{
					var tmp=this.heap[curr];
					this.heap[curr]=this.heap[next];
					this.heap[next]=tmp;
					curr=next;
				}
			}			
		}
		return ret;		
	}		
}









